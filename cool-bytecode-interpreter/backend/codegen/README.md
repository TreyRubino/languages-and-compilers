# The Code Generator  
Trey Rubino -  
CPSC 372 Independent Study -  
Dr. Schwesinger  

## Project Structure  
- `codegen.ml`: Entry point. Initializes IR state, assigns class and method IDs,
  and coordinates lowering for all classes and methods.  
- `lower.ml`: Core lowering logic. Translates typed COOL expressions, methods,
  and class bodies into IR and bytecode. Handles layout, dispatch, control flow,
  and constructors.  
- `layout.ml`: Computes stack-frame layouts for formals and locals. Assigns slot
  numbers and manages nested scope environments.  
- `gen.ml`: Maintains global IR construction state including constants, classes,
  methods, dispatch tables, and ID mappings. Produces the final IR record.  
- `emit.ml`: Bytecode emitter. Provides opcode emission, operand handling, and
  jump patching. Produces compact instruction arrays.  
- `ir.ml`: Defines IR structures: literals, class layouts, dispatch tables,
  methods, and instruction arrays.  
- `debug.ml`: Tools for generating readable dumps of class layouts, dispatch
  tables, constants, and bytecode.  

## Overview  
The code generation phase extends the compiler from static semantic correctness
into executable program construction. It translates fully type-checked COOL
programs into a structured intermediate representation consumed by the virtual
machine. This includes establishing class and object layouts, computing
inheritance-based dispatch tables, generating constructors for attribute
initialization, allocating stack-frame environments, and lowering user-defined
methods and expressions into bytecode instructions. By completing this phase,
every COOL program is represented as a deterministic, VM-ready artifact that
encodes the complete operational behavior of the language.

## Design  
The generator constructs a unified IR by combining class metadata, layout
information, dispatch tables, and bytecode for both constructors and ordinary
methods. Class identifiers are assigned in inheritance-depth order so that
parent object layouts and dispatch tables are fully available before lowering
subclasses. Frame layouts map variable names to numeric slots, enabling compact
local-variable access with no runtime lookup. Expression lowering applies COOL’s
operational semantics directly, ensuring correct evaluation order, attribute
access, dynamic and static dispatch, arithmetic operations, conditionals,
loops, let-bindings, and case expressions. Constructors are synthesized for
each class by chaining parent initializers and evaluating attribute initializers
in linearized inheritance order. Dispatch tables track method offsets based on
full class linearization, enforcing COOL’s overriding behavior and ensuring
consistent dynamic dispatch at runtime.

## Implementation  
The main code generation routine initializes IR construction state, assigns
class identifiers, installs placeholder constructor entries, and then lowers
classes in inheritance order. Constructors are generated by chaining the parent
constructor (if applicable), initializing attributes, and returning the self
object. Method lowering allocates a fresh frame layout and translates typed
expressions into bytecode sequences terminated by explicit return instructions.
The lowering engine emits bytecode by recursively traversing the annotated AST,
translating each COOL construct into a fixed opcode sequence. During this pass,
jump targets for conditionals, loops, and case expressions are patched using
instruction markers maintained by the emission buffer. After all classes and
methods are lowered, the IR is finalized by converting accumulated constants,
class layouts, and methods into arrays. The result is a complete `.cl-ir`
artifact that captures object layout, dispatch semantics, and executable
bytecode for the virtual machine.

## Testing  
Testing for the code generator focused on validating layout correctness, slot
assignment, constructor sequencing, and dispatch-table accuracy. Test programs
were compiled and their IR dumps manually inspected to confirm that attributes
were assigned correct offsets, dynamic dispatch slots aligned with inheritance
structure, and constructors correctly initialized inherited and local
attributes. Additional programs were executed on the VM to confirm operational
correctness of emitted bytecode including arithmetic evaluation, conditional
branching, loop semantics, let-bindings, case dispatch, and both dynamic and
static method calls. Negative tests were also used to ensure the code generator
never overrides or compensates for semantic errors rejected earlier in the
pipeline.

## References  
[1] “The Cool Reference Manual,” Alex Aiken (et al.), Stanford University, The COOL Language Project, Jan. 2011. 
[Online]. Available: https://theory.stanford.edu/~aiken/software/cool/cool-manual.pdf
